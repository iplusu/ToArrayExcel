/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package ToArrayExcel;

import java.awt.Component;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileNameExtensionFilter;

public class ToArrayExcel extends javax.swing.JFrame {
    private static final int MAX_PARENTS = 9;
    private static final int MAX_CHILDREN = 9;
    
    /** Creates new form ToArrayExcel */
    public ToArrayExcel() {
        initComponents();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jbChange = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("ToArrayExcel");

        jbChange.setText("Change it!!");
        jbChange.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jbChangeMouseClicked(evt);
            }
        });

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .add(128, 128, 128)
                .add(jbChange)
                .addContainerGap(127, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(jbChange, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 178, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    
    private String getTransactionArray(XmlReader xr){
        StringBuilder sb = new StringBuilder();
        int cnt = 0;
        
        sb.append("Transactions = [ ");
        for(cnt = 0; cnt < xr.throughputSet.size(); cnt++){
            ThroughputArraySet tas = xr.throughputSet.get(cnt);

            if(cnt != 0){
                sb.append(" ");
            }
            sb.append(tas.transaction);
        }
        sb.append("]\n\n");
        return sb.toString();
    }
    
    private String getTransactionExcel(XmlReader xr){
        StringBuilder sb = new StringBuilder();
        int cnt = 0;
        
        sb.append("Transactions, ");
        for(cnt = 0; cnt < xr.throughputSet.size(); cnt++){
            ThroughputArraySet tas = xr.throughputSet.get(cnt);

            if(cnt != 0){
                sb.append(", ");
            }
            sb.append(tas.transaction);
        }
        sb.append("\n");
        return sb.toString();
    }
    
    private String getThroughputArray(XmlReader xr){
        StringBuilder sb = new StringBuilder();
        int cnt = 0;
        
        sb.append("Throughput = [ ");
        for(cnt = 0; cnt < xr.throughputSet.size(); cnt++){
            ThroughputArraySet tas = xr.throughputSet.get(cnt);

            if(cnt != 0){
                sb.append(" ");
            }
            sb.append(tas.throughput);
        }
        sb.append("]\n\n");
        return sb.toString();
    }
    
    private String getThroughputExcel(XmlReader xr){
        StringBuilder sb = new StringBuilder();
        int cnt = 0;
        
        sb.append("Throughput, ");
        for(cnt = 0; cnt < xr.throughputSet.size(); cnt++){
            ThroughputArraySet tas = xr.throughputSet.get(cnt);

            if(cnt != 0){
                sb.append(", ");
            }
            sb.append(tas.throughput);
        }
        sb.append("\n");
        return sb.toString();
    }
    
    private String getThroughputHistoryArray(XmlReader xr){
        StringBuilder sb = new StringBuilder();
        int cnt = 0;
        double rate = 0.0, totalRates = 0.0;
        
        sb.append("ThroughputHis = [ ");
        for(cnt = 0; cnt < xr.throughputSet.size(); cnt++){
            ThroughputArraySet tas = xr.throughputSet.get(cnt);
            totalRates += tas.throughput;
            rate = (double)((double)totalRates/(double)(cnt+1));

            if(cnt != 0){
                sb.append(" ");
            }
            sb.append(rate);
        }
        sb.append("]\n\n");
        return sb.toString();
    }
    
    private String getThroughputHistoryExcel(XmlReader xr){
        StringBuilder sb = new StringBuilder();
        int cnt = 0;
        double rate = 0.0, totalRates = 0.0;
        
        sb.append("ThroughputHis, ");
        for(cnt = 0; cnt < xr.throughputSet.size(); cnt++){
            ThroughputArraySet tas = xr.throughputSet.get(cnt);
            totalRates += tas.throughput;
            rate = (double)((double)totalRates/(double)(cnt+1));

            if(cnt != 0){
                sb.append(", ");
            }
            sb.append(rate);
        }
        sb.append("\n");
        return sb.toString();
    }

    private String getTrustsArray(XmlReader xr){
        StringBuilder sb = new StringBuilder();
        StringBuilder nodeTransaction = new StringBuilder();
        StringBuilder nodeTime = new StringBuilder();
        StringBuilder nodeFPTrust = new StringBuilder();
        StringBuilder nodePRTrust = new StringBuilder();
        StringBuilder nodeOverallTrust = new StringBuilder();
        int cnt = 0, parent = 0, child = 0;
        boolean isExist = false;
        
        cnt = 0;
        for(parent = 0; parent < MAX_PARENTS; parent++){
            for(child = 0; child < MAX_CHILDREN; child++){
                nodeTransaction = new StringBuilder();
                nodeTime = new StringBuilder();
                nodeFPTrust = new StringBuilder();
                nodePRTrust = new StringBuilder();
                nodeOverallTrust = new StringBuilder();
                
                isExist = false;
                for(cnt = 0; cnt < xr.trustSet.size(); cnt++){
                    TrustArraySet tas = xr.trustSet.get(cnt);
                    if(parent == tas.source && child == tas.target){
                        if(isExist == false){
                            nodeTransaction.append(String.format("%d_TO_%d_TRANSACION = [ ", parent, child));
                            nodeTime.append(String.format("%d_TO_%d_TIME = [ ", parent, child));
                            nodeFPTrust.append(String.format("%d_TO_%d_FP = [ ", parent, child));
                            nodePRTrust.append(String.format("%d_TO_%d_PR = [ ", parent, child));
                            nodeOverallTrust.append(String.format("%d_TO_%d_Overall = [ ", parent, child));
                            isExist = true;
                        } else {
                            nodeTransaction.append(" ");
                            nodeTime.append(" ");
                            nodeFPTrust.append(" ");
                            nodePRTrust.append(" ");
                            nodeOverallTrust.append(" ");
                        }
                        
                        nodeTransaction.append(tas.transaction);
                        nodeTime.append(tas.time);
                        nodeFPTrust.append(tas.trustFP);
                        nodePRTrust.append(tas.trustPR);
                        nodeOverallTrust.append(tas.overall);
                    }
                }
                if(isExist == true){
                    nodeTransaction.append("]\n\n");
                    nodeTime.append("]\n\n");
                    nodeFPTrust.append("]\n\n");
                    nodePRTrust.append("]\n\n");
                    nodeOverallTrust.append("]\n\n");

                    sb.append(nodeTransaction.toString());
                    sb.append(nodeTime.toString());
                    sb.append(nodeFPTrust.toString());
                    sb.append(nodePRTrust.toString());
                    sb.append(nodeOverallTrust.toString());
                }
            }
        }
        
        return sb.toString();
    }
    
    private String getTrustsExcel(XmlReader xr){
        StringBuilder sb = new StringBuilder();
        StringBuilder nodeTransaction = new StringBuilder();
        StringBuilder nodeTime = new StringBuilder();
        StringBuilder nodeFPTrust = new StringBuilder();
        StringBuilder nodePRTrust = new StringBuilder();
        StringBuilder nodeOverallTrust = new StringBuilder();
        int cnt = 0, parent = 0, child = 0;
        boolean isExist = false;
        
        cnt = 0;
        for(parent = 0; parent < MAX_PARENTS; parent++){
            for(child = 0; child < MAX_CHILDREN; child++){
                nodeTransaction = new StringBuilder();
                nodeTime = new StringBuilder();
                nodeFPTrust = new StringBuilder();
                nodePRTrust = new StringBuilder();
                nodeOverallTrust = new StringBuilder();
                
                isExist = false;
                for(cnt = 0; cnt < xr.trustSet.size(); cnt++){
                    TrustArraySet tas = xr.trustSet.get(cnt);
                    if(parent == tas.source && child == tas.target){
                        if(isExist == false){
                            nodeTransaction.append(String.format("%d_TO_%d_TRANSACION, ", parent, child));
                            nodeTime.append(String.format("%d_TO_%d_TIME, ", parent, child));
                            nodeFPTrust.append(String.format("%d_TO_%d_FP, ", parent, child));
                            nodePRTrust.append(String.format("%d_TO_%d_PR, ", parent, child));
                            nodeOverallTrust.append(String.format("%d_TO_%d_Overall, ", parent, child));
                            isExist = true;
                        } else {
                            nodeTransaction.append(", ");
                            nodeTime.append(", ");
                            nodeFPTrust.append(", ");
                            nodePRTrust.append(", ");
                            nodeOverallTrust.append(", ");
                        }
                        
                        nodeTransaction.append(tas.transaction);
                        nodeTime.append(tas.time);
                        nodeFPTrust.append(tas.trustFP);
                        nodePRTrust.append(tas.trustPR);
                        nodeOverallTrust.append(tas.overall);
                    }
                }
                if(isExist == true){
                    nodeTransaction.append("\n");
                    nodeTime.append("\n");
                    nodeFPTrust.append("\n");
                    nodePRTrust.append("\n");
                    nodeOverallTrust.append("\n");

                    sb.append(nodeTransaction.toString());
                    sb.append(nodeTime.toString());
                    sb.append(nodeFPTrust.toString());
                    sb.append(nodePRTrust.toString());
                    sb.append(nodeOverallTrust.toString());
                }
            }
        }
        
        return sb.toString();
    }
    
    private void jbChangeMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jbChangeMouseClicked
        // TODO add your handling code here:
        JFileChooser fc = new JFileChooser(".");
        File arrayFile = null;
        File excelFile = null;
        FileWriter fwContent = null;
        BufferedWriter bwContent = null;
        
        fc.setFileSelectionMode(JFileChooser.FILES_ONLY);
        FileNameExtensionFilter ff = new FileNameExtensionFilter("SARP Replay (*.sre)", "sre");
        fc.setFileFilter(ff);
        int result = fc.showOpenDialog((Component)this);
        if (result == JFileChooser.APPROVE_OPTION) {
            String src = fc.getSelectedFile().getAbsoluteFile().toString().toLowerCase();
            String arrayFileName = src.replace(".sre", "_array.array");
            String excelFileName = src.replace(".sre", "_excel.csv");
            StringBuilder excelContent = new StringBuilder();
            StringBuilder arrayContent = new StringBuilder();
            
            XmlReader xr = new XmlReader(src);
            xr.parse();
            
            excelContent.append(getTransactionExcel(xr));
            excelContent.append(getThroughputExcel(xr));
            excelContent.append(getThroughputHistoryExcel(xr));
            
            arrayContent.append(getTransactionArray(xr));
            arrayContent.append(getThroughputArray(xr));
            arrayContent.append(getThroughputHistoryArray(xr));
            
            if(xr.trustSet != null){
                excelContent.append(getTrustsExcel(xr));
                arrayContent.append(getTrustsArray(xr));
            }
            
            try{
                excelFile = new File(excelFileName);
                fwContent = new FileWriter(excelFile, false);
                bwContent = new BufferedWriter(fwContent, 65536);
                bwContent.write(excelContent.toString());
                bwContent.newLine();
                bwContent.flush();
                bwContent.close();
                
                arrayFile = new File(arrayFileName);
                fwContent = new FileWriter(arrayFile, false);
                bwContent = new BufferedWriter(fwContent, 65536);
                bwContent.write(arrayContent.toString());
                bwContent.newLine();
                bwContent.flush();
                bwContent.close();
            } catch(IOException ex){
                Logger.getLogger(ToArrayExcel.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }//GEN-LAST:event_jbChangeMouseClicked
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ToArrayExcel().setVisible(true);
            }
        });
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jbChange;
    // End of variables declaration//GEN-END:variables
    
}
